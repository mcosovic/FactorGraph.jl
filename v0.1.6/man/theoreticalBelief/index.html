<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Continuous Variables · FactorGraph</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="FactorGraph logo"/></a><div class="docs-package-name"><span class="docs-autofit">FactorGraph</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Continuous Framework</span><ul><li><a class="tocitem" href="../continuousInput/">Input Data</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">General Factor Graph</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../continuousModel/">Graphical Model</a></li><li><a class="tocitem" href="../continuousInference/">Inference</a></li><li><a class="tocitem" href="../continuousOutput/">Output Data</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Tree Factor Graph</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../continuousTreeModel/">Graphical Model</a></li><li><a class="tocitem" href="../continuousTreeInference/">Inference</a></li><li><a class="tocitem" href="../continuousTreeOutput/">Output Data</a></li></ul></li><li><a class="tocitem" href="../utility/">Utility Functions</a></li></ul></li><li><span class="tocitem">Discrete Framework</span><ul><li><a class="tocitem" href="../discreteInput/">Input Data</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Tree Factor Graph</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../discreteTreeModel/">Graphical Model</a></li><li><a class="tocitem" href="../discreteTreeInference/">Inference</a></li><li><a class="tocitem" href="../discreteTreeOutput/">Output Data</a></li></ul></li></ul></li><li><span class="tocitem">Theoretical Background</span><ul><li><a class="tocitem" href="../theoreticalInference/">Inference in Factor Graphs</a></li><li class="is-active"><a class="tocitem" href>Continuous Variables</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Theoretical Background</a></li><li class="is-active"><a href>Continuous Variables</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Continuous Variables</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mcosovic/FactorGraph.jl/blob/master/docs/src/man/theoreticalBelief.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="continuousVariables"><a class="docs-heading-anchor" href="#continuousVariables">Continuous Gaussian random variables</a><a id="continuousVariables-1"></a><a class="docs-heading-anchor-permalink" href="#continuousVariables" title="Permalink"></a></h1><p>The Gaussian belief propagation (GBP) represents a class of the BP, where local function <span>$\psi(\mathcal{X}_i)$</span> is defined as a continuous Gaussian distribution:</p><p class="math-container">\[    \mathcal{N}(z_i|\mathcal{X}_i,v_i) \propto \exp\Bigg\{-\cfrac{[z_i-h(\mathcal{X}_i)]^2}{2v_i}\Bigg\},\]</p><p>where <span>$v_i$</span> is the variance, and the function <span>$h(\mathcal{X}_i)$</span> connects the set of state variables <span>$\mathcal{X}_i$</span> to the known <span>$z_i$</span> value. The linear-GBP model implies the linear function <span>$h(\mathcal{X}_i)$</span>. If the linear-GBP algorithm converges, it will converge to a fixed point representing a true means [1], regardless of the structure of the factor graph. Unlike means, the variances of the linear-GBP algorithm may not converge to correct values for graphical models with loops, while for models without loops (i.e., tree factor graph) variances will have exact values.</p><p>Thus, as an input, we observe a noisy linear system of equations with real coefficients and variables:</p><p class="math-container">\[        \mathbf{z}=\mathbf{h}(\mathbf{x})+\mathbf{u},\]</p><p>where <span>$\mathbf {x}=[x_1,\dots,x_{n}]^{{T}}$</span> is the vector of the state variables, <span>$\mathbf{h}(\mathbf{x})= [h_1(\mathbf{x})$</span>, <span>$\dots$</span>, <span>$h_k(\mathbf{x})]^{{T}}$</span> is the vector of observation functions, <span>$\mathbf{z} = [z_1,\dots,z_m]^{{T}}$</span> is the vector of observation values, and <span>$\mathbf{u} = [u_1,\dots,u_k]^{{T}}$</span> is the vector of uncorrelated observation errors. The linear system of equations is an overdetermined <span>$m&gt;n$</span> arising in many technical fields, such as statistics, signal processing, and control theory.</p><p>Each observation is associated with observed value <span>$z_i$</span>, error  <span>$u_i$</span>, and function <span>$h_i(\mathbf{x})$</span>. Under the assumption that observation errors <span>$u_i$</span> follow a zero-mean Gaussian distribution, the probability density function associated with the <span>$i$</span>-th observation is proportional to:</p><p class="math-container">\[    \mathcal{N}(z_i|\mathbf{x},v_i) \propto \exp\Bigg\{-\cfrac{[z_i-h_i(\mathbf{x})]^2}{2v_i}\Bigg\},\]</p><p>where <span>$v_i$</span> is the observation variance defined by the error <span>$u_i$</span>, and the function <span>$h_i(\mathbf{x})$</span> connects the vector of state variables <span>$\mathbf{x}$</span> to the value of the <span>$i$</span>-th observation.</p><p>The goal is to determine state variables <span>$\mathbf{x}$</span> according to the noisy observed data <span>$\mathbf{z}$</span> and a prior knowledge:</p><p class="math-container">\[    p(\mathbf{x}|\mathbf{z})= \cfrac{p(\mathbf{z}|\mathbf{x})p(\mathbf{x})}{p(\mathbf{z})}.\]</p><p>Assuming that the prior probability distribution <span>$p(\mathbf{x})$</span> is uniform, and given that <span>$p(\mathbf{z})$</span> does not depend on <span>$\mathbf{x}$</span>, the maximum a posteriori solution reduces to the maximum likelihood solution, as given below:</p><p class="math-container">\[    \hat{\mathbf{x}}= \mathrm{arg}\max_{\mathbf{x}}p(\mathbf{x}|\mathbf{z})= \mathrm{arg}\max_{\mathbf{x}}p(\mathbf{z}|\mathbf{x})=
    \mathrm{arg}\max_{\mathbf{x}}\mathcal{L}(\mathbf{z}|\mathbf{x}).\]</p><p>One can find the solution via maximization of the likelihood function <span>$\mathcal{L}(\mathbf{z}|\mathbf{x})$</span>, which is defined via likelihoods:</p><p class="math-container">\[    \hat{\mathbf x}= \mathrm{arg} \max_{\mathbf{x}}\mathcal{L}(\mathbf{z}|\mathbf{x})=
    \mathrm{arg} \max_{\mathbf{x}} \prod_{i=1}^m \mathcal{N}(z_i|\mathbf{x},v_i).\]</p><p>It can be shown that the maximum a posteriori solution can be obtained by solving the following optimization problem, known as the weighted least-squares (WLS) problem:</p><p class="math-container">\[    \hat{\mathbf x} = \mathrm{arg}\min_{\mathbf{x}} \sum_{i=1}^m  \cfrac{[z_i-h_i(\mathbf x)]^2}{v_i}.\]</p><p>The state estimate <span>$\hat{\mathbf x}$</span> representing the solution of the optimization problem is known as the WLS estimator. The maximum likelihood and WLS estimator are equivalent to the maximum a posteriori solution.</p><hr/><h3 id="vanillaGBP"><a class="docs-heading-anchor" href="#vanillaGBP">Vanilla GBP algorithm</a><a id="vanillaGBP-1"></a><a class="docs-heading-anchor-permalink" href="#vanillaGBP" title="Permalink"></a></h3><p>Under the vanilla GBP algorithm, we imply the algorithm in which messages are calculated as described below.</p><h4 id="Message-from-a-factor-node-to-a-variable-node"><a class="docs-heading-anchor" href="#Message-from-a-factor-node-to-a-variable-node">Message from a factor node to a variable node</a><a id="Message-from-a-factor-node-to-a-variable-node-1"></a><a class="docs-heading-anchor-permalink" href="#Message-from-a-factor-node-to-a-variable-node" title="Permalink"></a></h4><p>Let us assume that the incoming messages <span>$\mu_{f_w \to x_s}(x_s)$</span>, <span>$\dots$</span>, <span>$\mu_{f_W \to x_s}(x_s)$</span> into the variable node <span>$x_s$</span> are Gaussian and represented by their mean-variance pairs <span>$(z_{f_w \to x_s},v_{f_w \to x_s})$</span>, <span>$\dots$</span>, <span>$(z_{f_W \to x_s},v_{f_W \to x_s})$</span>. Note that these messages carry beliefs about the variable node <span>$x_s$</span> provided by its neighbouring factor nodes <span>$\mathcal{F}_s\setminus f_i$</span>. It can be shown that the message <span>$\mu_{x_s \to f_i}(x_s)$</span> from the variable node <span>$x_s$</span> to the factor node <span>$f_i$</span> is proportional to:</p><p class="math-container">\[    \mu_{x_s \to f_i}(x_s) \propto \mathcal{N}(x_s|z_{x_s \to f_i}, v_{x_s \to f_i}),\]</p><p>with mean <span>$z_{x_s \to f_i}$</span> and variance <span>$v_{x_s \to f_i}$</span> obtained as:</p><p class="math-container">\[    z_{x_s \to f_i} = \Bigg( \sum_{f_a \in \mathcal{F}_s\setminus f_i} \cfrac{z_{f_a \to x_s}}{v_{f_a \to x_s}}\Bigg) v_{x_s \to f_i} \\
    \cfrac{1}{v_{x_s \to f_i}} = \sum_{f_a \in \mathcal{F}_s\setminus f_i} \cfrac{1}{v_{f_a \to x_s}}.\]</p><p>After the variable node <span>$x_s$</span> receives the messages from all of the neighbouring factor nodes from the set <span>$\mathcal{F}_s\setminus f_i$</span>, it evaluates the message <span>$\mu_{x_s \to f_i}(x_s)$</span>, and sends it to the factor node <span>$f_i$</span>.</p><h4 id="Message-from-a-factor-node-to-a-variable-node-2"><a class="docs-heading-anchor" href="#Message-from-a-factor-node-to-a-variable-node-2">Message from a factor node to a variable node</a><a class="docs-heading-anchor-permalink" href="#Message-from-a-factor-node-to-a-variable-node-2" title="Permalink"></a></h4><p>Due to linearity of the functions <span>$h_i(\mathcal{X}_i)$</span>, closed form expressions for these messages is easy to obtain and follow a Gaussian form:</p><p class="math-container">\[    \mu_{f_i \to x_s}(x_s) \propto \mathcal{N}(x_s|z_{f_i \to x_s},v_{f_i \to x_s}).\]</p><p>The message <span>$\mu_{f_i \to x_s}(x_s)$</span> can be computed only when all other incoming messages (variable to factor node messages) are known. Let us assume that the messages into factor nodes are Gaussian, denoted by:</p><p class="math-container">\[        \mu_{x_l \to f_i}(x_l) \propto \mathcal{N}(x_l|z_{x_l \to f_i}, v_{x_l \to f_i})\\
        \vdots\\
        \mu_{x_L \to f_i}(x_L) \propto \mathcal{N}(x_L|z_{x_L \to f_i}, v_{x_L \to f_i}).\]</p><p>The Gaussian function associated with the factor node <span>$f_i$</span> is:</p><p class="math-container">\[    \mathcal{N}(z_i|\mathcal{X}_i, v_i) \propto \exp\Bigg\{-\cfrac{[z_i-h_i(\mathcal{X}_i)]^2} {2v_i}\Bigg\}.\]</p><p>The model contains only linear functions which we represent in a general form as:</p><p class="math-container">\[    h_i(\mathcal{X}_i) = C_{x_s} x_s + \sum_{x_b \in \mathcal{X}_i\setminus x_s} C_{x_b} x_b,\]</p><p>where <span>$\mathcal{X}_i\setminus x_s$</span> is the set of variable nodes incident to the factor node <span>$f_i$</span>, excluding the variable node <span>$x_s$</span>.</p><p>It can be shown that the message <span>$\mu_{f_i \to x_s}(x_s)$</span> from the factor node <span>$f_i$</span> to the variable node <span>$x_s$</span> is represented by the Gaussian function \eqref{BP<em>Gauss</em>fv}, with mean <span>$z_{f_i \to x_s}$</span> and variance <span>$v_{f_i \to x_s}$</span> obtained as:</p><p class="math-container">\[        z_{f_i \to x_s} = \cfrac{1}{C_{x_s}} \Bigg(z_i - \sum_{x_b \in \mathcal{X}_i \setminus x_s}
        C_{x_b} z_{x_b \to f_i} \Bigg)\\
        v_{f_i \to x_s} = \cfrac{1}{C_{x_s}^2} \Bigg( v_i + \sum_{x_b \in \mathcal{X}_i \setminus x_s} C_{x_b}^2 v_{x_b \to f_i}  \Bigg).\]</p><p>To summarise, after the factor node <span>$f_i$</span> receives the messages from all of the neighbouring variable nodes from the set <span>$\mathcal{X}_i\setminus x_s$</span>, it evaluates the message <span>$\mu_{f_i \to x_s}(x_s)$</span>, and sends it to the variable node <span>$x_s$</span>.</p><h4 id="Marginal-inference"><a class="docs-heading-anchor" href="#Marginal-inference">Marginal inference</a><a id="Marginal-inference-1"></a><a class="docs-heading-anchor-permalink" href="#Marginal-inference" title="Permalink"></a></h4><p>It can be shown that the marginal of the state variable <span>$x_s$</span> is represented by:</p><p class="math-container">\[    p(x_s) \propto \mathcal{N}(x_s|\hat x_s,v_{x_s}),\]</p><p>with the mean value <span>$\hat x_s$</span> and variance <span>$v_{x_s}$</span>:</p><p class="math-container">\[    \hat x_s = \Bigg( \sum_{f_c \in \mathcal{F}_s} \cfrac{z_{f_c \to x_s}}{v_{f_c \to x_s}}\Bigg) v_{x_s} \\
    \cfrac{1}{v_{x_s}} = \sum_{f_c \in \mathcal{F}_s} \cfrac{1}{v_{f_c \to x_s}}.\]</p><p>Finally, the mean-value <span>$\hat x_s$</span> is adopted as the estimated value of the state variable <span>$x_s$</span>.</p><hr/><h3 id="broadcastGBP"><a class="docs-heading-anchor" href="#broadcastGBP">Broadcast GBP algorithm</a><a id="broadcastGBP-1"></a><a class="docs-heading-anchor-permalink" href="#broadcastGBP" title="Permalink"></a></h3><p>We can make a substantial improvement to the vanilla GBP algorithm&#39;s complexity by reducing the number of calculations per outgoing messages. We achieve this reduction by summarisation of all incoming messages for each variable and factor node instead of summarising all incoming messages per each outgoing message. This simple trick, allow a single variable or factor node to share these summations across all outgoing messages, hence calculating these summations only once. As a result, each outgoing message involves a constant number of operations improving the worst-case running complexity to <span>$\mathcal{O}(nm)$</span>. In this framework, we calculate the message from the variable node to the factor node as:</p><p class="math-container">\[        z_{x_s \to f_i} = \Bigg(z_{x_s} - \cfrac{z_{f_i \to x_s}}{v_{f_i \to x_s}}\Bigg) v_{x_s \to f_i} \\
        \cfrac{1}{v_{x_s \to f_i}} = w_{x_s} - \cfrac{1}{v_{f_i \to x_s}},\]</p><p>where:</p><p class="math-container">\[    z_{x_s} = \sum_{f_a \in \mathcal{F}_s} \cfrac{z_{f_a \to x_s}}{v_{f_a \to x_s}};  \quad
    w_{x_s} = \sum_{f_a \in \mathcal{F}_s} \cfrac{1}{v_{f_a \to x_s}}.\]</p><p>Likewise, the message from the factor node to the variable node is:</p><p class="math-container">\[    z_{f_i \to x_s} = \cfrac{1}{C_{x_s}} \left(z_i - z_{f_i} \right) + z_{x_s \to f_i} \\
    v_{f_i \to x_s} = \cfrac{1}{C_{x_s}^2} \left( v_i +  v_{f_i}  \right) - v_{x_s \to f_i},\]</p><p>where:</p><p class="math-container">\[    z_{f_i} = \sum_{x_b \in \mathcal{X}_i} C_{x_b} z_{x_b \to f_i};  \quad
    v_{f_i} = \sum_{x_b \in \mathcal{X}_i} C_{x_b}^2 v_{x_b \to f_i}.\]</p><hr/><h3 id="kahanGBP"><a class="docs-heading-anchor" href="#kahanGBP">Broadcast GBP and Kahan–Babuška algorithm</a><a id="kahanGBP-1"></a><a class="docs-heading-anchor-permalink" href="#kahanGBP" title="Permalink"></a></h3><p>The major drawback of the broadcast GBP algorithm is sensitivity to numerical errors because of the summation of floating-point numbers, due to possible significant differences in the values of incoming means and variances. However, this limitation can be alleviated with a compensated summation algorithm, such as the Kahan summation or the improved Kahan–Babuška algorithm. These algorithms increase the complexity of the operations by a constant factor, which means the time complexity of the worst-case remains unaffected. More precisely, we do summation that exists in the messages as:</p><pre><code class="language-julia-repl">function kahan(summands, total, epsilon)
    t = total + summands
    if abs(total) &gt;= abs(summands)
        epsilon += (total - t) + summands
    else
        epsilon += (summands - t) + total
    end
    total = t

    return total, epsilon
end</code></pre><hr/><h3 id="dampGBP"><a class="docs-heading-anchor" href="#dampGBP">The GBP with randomized damping</a><a id="dampGBP-1"></a><a class="docs-heading-anchor-permalink" href="#dampGBP" title="Permalink"></a></h3><p>We propose a randomized damping approach, where each mean value message from factor node to a variable node is damped independently with probability <span>$p$</span>, otherwise, the message is calculated as in the standard the GBP algorithm. The damped message is evaluated as a linear combination of the message from the previous and the current iteration, with weights <span>$\alpha$</span> and <span>$1 - \alpha$</span>, respectively. More, precisly, the proposed randomized damping scheduling updates of selected factor to variable node means in every iteration by combining them with their values from the previous iteration using convergence parameters <span>$p$</span> and <span>$\alpha$</span>:</p><p class="math-container">\[    z_{f_{i} \rightarrow x_{s}}^{(\tau)}=\left(1-q_{i s}\right) \cdot z_{f_{i} \rightarrow x_{s}}^{(\tau)}+q_{i s} \cdot\left(\alpha \cdot z_{f_{x} \rightarrow x_{s}}^{(\tau-1)}+(1-\alpha) \cdot z_{f_{i} \rightarrow x_{a}}^{(\tau)}\right),\]</p><p>where <span>$q_{i s} \sim \operatorname{Ber}(p) \in\{0,1\}$</span> is independently sampled with probability <span>$p$</span> for the mean from factor node <span>$f_i$</span> to the variable node <span>$x_s$</span>.</p><p>The randomised damping parameter pairs lead to a trade-off between the number of non-converging simulations and the rate of convergence. In general, we observe a large number of non-converging simulations for the selection of <code>prob</code> and <code>alpha</code> for which only a small fraction of messages are combined with their values in a previous iteration, and that is a case for <code>prob</code> close to 0 or <code>alpha</code> close to 1.</p><hr/><h3 id="dynamicGBP"><a class="docs-heading-anchor" href="#dynamicGBP">Dynamic GBP algorithm</a><a id="dynamicGBP-1"></a><a class="docs-heading-anchor-permalink" href="#dynamicGBP" title="Permalink"></a></h3><p>To recall, each factor node is associated with the observation <span>$z_i$</span> and variance value <span>$v_i$</span>. The dynamic framework allows the update of these values in any GBP iteration <span>$\tau$</span>. This framework is an extension to the real-time model that operates continuously and accepts asynchronous data. Such data are continuously integrated into the running instances of the GBP algorithm. Hence, the GBP algorithm can update the state estimate vector in a time-continuous process.</p><p>Additionally, this framework allows for the artificial addition and removal of factor nodes. Then, the initial factor graph, described with the coefficient matrix, should include all possible factor nodes. Factor nodes that are not active are then taken into account via extremely large values of variances (e.g., <span>$10^{60}$</span>). Consequently, estimates will have a unique solution according to variances whose values are much smaller than <span>$10^{60}$</span>.</p><hr/><h3 id="ageingGBP"><a class="docs-heading-anchor" href="#ageingGBP">Ageing GBP algorithm</a><a id="ageingGBP-1"></a><a class="docs-heading-anchor-permalink" href="#ageingGBP" title="Permalink"></a></h3><p>The ageing framework represents an extension of the dynamic model and establishes a model for data arrival processes and for the process of data deterioration or ageing over time (or GBP iterations). We integrate these data regularly into the running instances of the GBP algorithm.</p><p>Let us assume that factor node <span>$f_i$</span> receives the new variance <span>$v_{i}$</span>. After that moment, the ageing model increases variance value over iterations <span>$v_i(\tau)$</span>. More precisely, we associate the Gaussian distribution <span>$\mathcal{N}(z_i|\mathcal{X}_i, v_i(\tau))$</span> to the corresponding factor node <span>$f_i$</span>, where the variance <span>$v_i(\tau)$</span> increases its value starting from the predefined variance <span>$v_i(\tau) = v_i$</span>. Finally, in practice ageing model requires defining a limit from above <span>$\bar {v}_i$</span> of a function <span>$v_i(\tau)$</span>, instead of allowing variance to take on extremely large values.</p><p>Depending on the data arriving dynamic, an adaptive mechanism for increasing the variance over iterations <span>$v_i(\tau)$</span> can be derived. The logarithmic growth model represents a promising solution for systems with a high sampling rate of the data, where a rapid increase in variance is required:</p><p class="math-container">\[    v_i(\tau) = \begin{cases}
      a \, \text{log} \left(\cfrac{\tau + 1 + b}{1 + b} \right ) + v_i, &amp; 1 \leq \tau \leq \theta \\
      \bar {v}_i, &amp; \tau \geq \theta,
  \end{cases}\]</p><p>where <span>$a$</span> and <span>$b$</span> control the rate of growth.  In contrast, the exponential growth model corresponds to systems with a low sampling rate of the data:</p><p class="math-container">\[    v_i(\tau) = \begin{cases}
      v_i(1+b)^{a\tau}, &amp; 1 \leq \tau \leq \theta \\
      \bar {v}_i, &amp; \tau \geq \theta.
  \end{cases}\]</p><p>Finally, the linear growth model can be observed as a compromise between logarithmic and exponential growth models:</p><p class="math-container">\[    v_i(\tau) = \begin{cases}
      a\tau + v_i, &amp; 1 \leq \tau \leq \theta \\
      \bar {v}_i, &amp; \tau \geq \theta.
  \end{cases}\]</p><hr/><h3 id="refsBelief"><a class="docs-heading-anchor" href="#refsBelief">References</a><a id="refsBelief-1"></a><a class="docs-heading-anchor-permalink" href="#refsBelief" title="Permalink"></a></h3><p>[1] D. Bickson, <em>Gaussian Belief Propagation: Theory and Aplication,</em> ArXiv e-prints, Nov. 2008.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../theoreticalInference/">« Inference in Factor Graphs</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 3 July 2022 11:00">Sunday 3 July 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
