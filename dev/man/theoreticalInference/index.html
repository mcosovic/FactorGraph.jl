<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Inference in Factor Graphs · FactorGraph</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="FactorGraph logo"/></a><div class="docs-package-name"><span class="docs-autofit">FactorGraph</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Continuous Framework</span><ul><li><a class="tocitem" href="../continuousInput/">Input Data</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">General Factor Graph</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../continuousModel/">Graphical Model</a></li><li><a class="tocitem" href="../continuousInference/">Inference</a></li><li><a class="tocitem" href="../continuousOutput/">Output Data</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Tree Factor Graph</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../continuousTreeModel/">Graphical Model</a></li><li><a class="tocitem" href="../continuousTreeInference/">Inference</a></li><li><a class="tocitem" href="../continuousTreeOutput/">Output Data</a></li></ul></li><li><a class="tocitem" href="../utility/">Utility Functions</a></li></ul></li><li><span class="tocitem">Discrete Framework</span><ul><li><a class="tocitem" href="../discreteInput/">Input Data</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Tree Factor Graph</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../discreteTreeModel/">Graphical Model</a></li><li><a class="tocitem" href="../discreteTreeInference/">Inference</a></li><li><a class="tocitem" href="../discreteTreeOutput/">Output Data</a></li></ul></li></ul></li><li><span class="tocitem">Theoretical Background</span><ul><li class="is-active"><a class="tocitem" href>Inference in Factor Graphs</a></li><li><a class="tocitem" href="../theoreticalBelief/">Continuous Variables</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Theoretical Background</a></li><li class="is-active"><a href>Inference in Factor Graphs</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Inference in Factor Graphs</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mcosovic/FactorGraph.jl/blob/master/docs/src/man/theoreticalInference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="inferenceFactorGraphs"><a class="docs-heading-anchor" href="#inferenceFactorGraphs">Inference in Factor Graphs</a><a id="inferenceFactorGraphs-1"></a><a class="docs-heading-anchor-permalink" href="#inferenceFactorGraphs" title="Permalink"></a></h1><p>In the standard setup, we observe the set of random variables <span>$\mathcal{X} = \{x_1,\dots,x_n\}$</span> described via the joint probability density function <span>$g(\mathcal{X})$</span>. Assuming the function <span>$g(\mathcal{X})$</span> can be factorised proportionally (<span>$\propto$</span>) to a product of local functions:</p><p class="math-container">\[    g(\mathcal{X}) \propto \prod_{i=1}^m \psi(\mathcal{X}_i),\]</p><p>where <span>$\mathcal{X}_i \subseteq \mathcal{X}$</span>. The first step is forming a factor graph, which is a bipartite graph that describes the structure of the factorisation. Factor graph allows a graph-based representation of probability density functions using variable and factor nodes connected by edges. In contrast to directed and undirected graphical models, factor graphs provide the details of the factorisation more explicitly. The factor graph structure comprises the set of factor nodes <span>$\mathcal{F}=\{f_1,\dots,f_m\}$</span>, where each factor node  <span>$f_i$</span> represents local function <span>$\psi(\mathcal{X}_i)$</span>, and the set of variable nodes <span>$\mathcal{X}$</span>. The factor node <span>$f_i$</span> connects to the variable node <span>$x_s$</span> if and only if <span>$x_s \in \mathcal{X}_i$</span>.</p><p>The message passing algorithm on factor graphs proceeds by passing two types of messages along the edges of the factor graph:</p><ul><li>a variable node <span>$x_s \in \mathcal{X}$</span> to a factor node <span>$f_i \in \mathcal{F}$</span> message <span>$\mu_{x_s \to f_i}(x_s)$</span>, and</li><li>a factor node <span>$f_i \in \mathcal{F}$</span> to a variable node <span>$x_s \in \mathcal{X}$</span> message <span>$\mu_{f_i \to x_s}(x_s)$</span>.</li></ul><p>Both variable and factor nodes in a factor graph process the incoming messages and calculate outgoing messages, where an output message on any edge depends on incoming messages from all other edges. The messages represent &quot;beliefs&quot; about variable nodes, thus a message that arrives or departs a certain variable node is a function (distribution) of the random variable corresponding to the variable node.</p><p>Here we shall focus on the problem of evaluating local marginals over variable nodes <span>$\mathcal{X} = \{x_1,\dots,x_n\}$</span> described via the joint probability density function <span>$g(\mathcal{X})$</span>, which will lead us to the belief propagation (BP) algorithm, also known as the sum-product algorithm [1].</p><hr/><h3 id="variableFactorMessage"><a class="docs-heading-anchor" href="#variableFactorMessage">Message from a variable node to a factor node</a><a id="variableFactorMessage-1"></a><a class="docs-heading-anchor-permalink" href="#variableFactorMessage" title="Permalink"></a></h3><p>Consider a part of a factor graph with a group of factor nodes <span>$\mathcal{F}_s=\{f_i,f_w,...,f_W\}$</span> <span>$\subseteq$</span> <span>$\mathcal{F}$</span> that are neighbours of the variable node <span>$x_s \in \mathcal{X}$</span>. The message <span>$\mu_{x_s \to f_i}(x_s)$</span> from the variable node <span>$x_s$</span> to the factor node <span>$f_i$</span> is equal to the product of all incoming factor node to variable node messages arriving at all the other incident edges:</p><p class="math-container">\[    \mu_{x_s \to f_i}(x_s) =\prod_{f_a \in \mathcal{F}_s \setminus f_i} \mu_{f_a \to x_s}(x_s),\]</p><p>where <span>$\mathcal{F}_s \setminus f_i$</span> represents the set of factor nodes incident to the variable node <span>$x_s$</span>, excluding the factor node <span>$f_i$</span>. Note that each message is a function of the variable <span>$x_s$</span>.</p><hr/><h3 id="factorVariableMessage"><a class="docs-heading-anchor" href="#factorVariableMessage">Message from a factor node to a variable node</a><a id="factorVariableMessage-1"></a><a class="docs-heading-anchor-permalink" href="#factorVariableMessage" title="Permalink"></a></h3><p>Consider a part of a factor graph that consists of a group of variable nodes <span>$\mathcal{X}_i = \{x_s, x_l,...,x_L\}$</span> <span>$\subseteq$</span> <span>$\mathcal X$</span> that are neighbours of the factor node <span>$f_i$</span> <span>$\in$</span> <span>$\mathcal{F}$</span>. The message <span>$\mu_{f_i \to x_s}(x_s)$</span> from the factor node <span>$f_i$</span> to the variable node <span>$x_s$</span> is defined as a product of all incoming variable node to factor node messages arriving at other incident edges, multiplied by the function <span>$\psi_i(\mathcal{X}_i)$</span> associated to the factor node <span>$f_i$</span>, and marginalised over all of the variables associated with the incoming messages:</p><p class="math-container">\[    \mu_{f_i \to x_s}(x_s)= \sum\limits_{x_l}\dots\sum\limits_{x_L} \psi_i(\mathcal{X}_i)
    \prod_{x_b \in \mathcal{X}_i\setminus x_s} \mu_{x_b \to f_i}(x_b),\]</p><p>where <span>$\mathcal{X}_i\setminus x_s$</span> is the set of variable nodes incident to the factor node <span>$f_i$</span>, excluding the variable node <span>$x_s$</span>. For continuous variables the summations are simply replaced by integrations:</p><p class="math-container">\[    \mu_{f_i \to x_s}(x_s)= \int\limits_{x_l}\dots\int\limits_{x_L} \psi_i(\mathcal{X}_i)
    \prod_{x_b \in \mathcal{X}_i\setminus x_s} \big[\mu_{x_b \to f_i}(x_b) \cdot \mathrm{d}x_b\big].\]</p><hr/><h3 id="marginal"><a class="docs-heading-anchor" href="#marginal">Marginal inference</a><a id="marginal-1"></a><a class="docs-heading-anchor-permalink" href="#marginal" title="Permalink"></a></h3><p>The marginal of the variable node <span>$x_s$</span> is obtained as the product of all incoming messages into the variable node <span>$x_s$</span>:</p><p class="math-container">\[    p(x_s) =\prod_{f_c \in \mathcal{F}_s} \mu_{f_c \to x_s}(x_s),\]</p><p>where <span>$\mathcal{F}_s$</span> is the set of factor nodes incident to the variable node <span>$x_s$</span>.</p><hr/><h3 id="MessagePassingSchedule"><a class="docs-heading-anchor" href="#MessagePassingSchedule">Message passing schedule</a><a id="MessagePassingSchedule-1"></a><a class="docs-heading-anchor-permalink" href="#MessagePassingSchedule" title="Permalink"></a></h3><p>The GBP or BP is an iterative algorithm, and requires a message-passing schedule. Typically, the message updating procedure can be implemented using:</p><ul><li>synchronous schedule, or</li><li>forward-backward schedule.</li></ul><h4 id="synchronousSchedule"><a class="docs-heading-anchor" href="#synchronousSchedule">Synchronous message passing schedule</a><a id="synchronousSchedule-1"></a><a class="docs-heading-anchor-permalink" href="#synchronousSchedule" title="Permalink"></a></h4><p>The scheduling where messages from variable to factor nodes, and messages from factor nodes to variable nodes, are updated in parallel in respective half-iterations, is known as synchronous scheduling. Synchronous scheduling updates all messages in a given iteration using the output of the previous iteration as an input. The synchronous scheduling allows inference for an arbitrary factor graph structure.</p><h4 id="treeSchedule"><a class="docs-heading-anchor" href="#treeSchedule">Forward-backward message passing schedule</a><a id="treeSchedule-1"></a><a class="docs-heading-anchor-permalink" href="#treeSchedule" title="Permalink"></a></h4><p>The forward–backward schedule allows exact inference in tree factor graph. We start by viewing an arbitrary variable node as the root of the factor graph and initiating messages at the leaves of the tree factor graph using. The message passing steps from variable nodes to factor nodes and from factor nodes to variable nodes are then applied recursively until messages have been propagated along every link, and the root node has received messages from all of its neighbours. Each node can send a message towards the root once it has received messages from all of its other neighbours. This step is known as the forward recursion.</p><p>The backward recursion starts when the root node received messages from all of its neighbours. It can therefore send out messages to all of its neighbours. These in turn will then have received messages from all of their neighbours and so can send out messages along the links going away from the root, and so on. In this way, messages are passed outwards from the root all the way to the leaves.</p><p>By now, a message will have passed in both directions across every link in the graph, and every node will have received a message from all of its neighbours. Every variable node will have received messages from all of its neighbours, we can readily calculate the marginal distribution for every variable in the graph. The number of messages that have to be computed is given by twice the number of links in the graph and so involves only twice the computation involved in finding a single marginal [1].</p><h4 id="initialisationProcedure"><a class="docs-heading-anchor" href="#initialisationProcedure">Initialisation procedure</a><a id="initialisationProcedure-1"></a><a class="docs-heading-anchor-permalink" href="#initialisationProcedure" title="Permalink"></a></h4><p>The Initialisation step starts with messages from singly connected factor nodes to variable nodes. Then, variable nodes forward the incoming messages received from singly connected factor nodes along remaining edges. To ensure this, we are using virtual factor nodes. Hence, the virtual factor node is a singly connected factor node used if the variable node is not directly observed. In a typical scenario, without prior knowledge, the variance of virtual factor nodes tend to infinity for continuous variables. Then, we also improve convergence performance using virtual factor nodes. For discrete variables messages from virtual factor nodes are set to unity.</p><hr/><h3 id="refs"><a class="docs-heading-anchor" href="#refs">References</a><a id="refs-1"></a><a class="docs-heading-anchor-permalink" href="#refs" title="Permalink"></a></h3><p>[1] C. M. Bishop, <em>Pattern Recognition and Machine Learning</em> (Information Science and Statistics). Berlin, Heidelberg: Springer-Verlag, 2006.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../discreteTreeOutput/">« Output Data</a><a class="docs-footer-nextpage" href="../theoreticalBelief/">Continuous Variables »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 3 July 2022 09:16">Sunday 3 July 2022</span>. Using Julia version 1.6.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
